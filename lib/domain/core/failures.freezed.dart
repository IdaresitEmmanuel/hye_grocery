// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  EmptyUserName<T> emptyUserName<T>({required String failedValue}) {
    return EmptyUserName<T>(
      failedValue: failedValue,
    );
  }

  InvalidEmail<T> invalidEmail<T>({required String failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

  ShortPassword<T> shortPassword<T>({required String failedValue}) {
    return ShortPassword<T>(
      failedValue: failedValue,
    );
  }

  PasswordMisMatch<T> passwordMisMatch<T>({required String failedValue}) {
    return PasswordMisMatch<T>(
      failedValue: failedValue,
    );
  }

  InvalidPhoneNumber<T> invalidPhoneNumber<T>({required String failedValue}) {
    return InvalidPhoneNumber<T>(
      failedValue: failedValue,
    );
  }

  InvalidCardNumber<T> invalidCardNumber<T>({required String failureValue}) {
    return InvalidCardNumber<T>(
      failureValue: failureValue,
    );
  }

  EmptyCardName<T> emptyCardName<T>({required String failedValue}) {
    return EmptyCardName<T>(
      failedValue: failedValue,
    );
  }

  InvalidCardDate<T> invalidCardDate<T>({required String failureValue}) {
    return InvalidCardDate<T>(
      failureValue: failureValue,
    );
  }

  InvalidCVV<T> invalidCVV<T>({required String failureValue}) {
    return InvalidCVV<T>(
      failureValue: failureValue,
    );
  }
}

/// @nodoc
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;
}

/// @nodoc
abstract class $EmptyUserNameCopyWith<T, $Res> {
  factory $EmptyUserNameCopyWith(
          EmptyUserName<T> value, $Res Function(EmptyUserName<T>) then) =
      _$EmptyUserNameCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$EmptyUserNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyUserNameCopyWith<T, $Res> {
  _$EmptyUserNameCopyWithImpl(
      EmptyUserName<T> _value, $Res Function(EmptyUserName<T>) _then)
      : super(_value, (v) => _then(v as EmptyUserName<T>));

  @override
  EmptyUserName<T> get _value => super._value as EmptyUserName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(EmptyUserName<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EmptyUserName<T> implements EmptyUserName<T> {
  const _$EmptyUserName({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.emptyUserName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmptyUserName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $EmptyUserNameCopyWith<T, EmptyUserName<T>> get copyWith =>
      _$EmptyUserNameCopyWithImpl<T, EmptyUserName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return emptyUserName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return emptyUserName?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (emptyUserName != null) {
      return emptyUserName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return emptyUserName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return emptyUserName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (emptyUserName != null) {
      return emptyUserName(this);
    }
    return orElse();
  }
}

abstract class EmptyUserName<T> implements ValueFailure<T> {
  const factory EmptyUserName({required String failedValue}) =
      _$EmptyUserName<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $EmptyUserNameCopyWith<T, EmptyUserName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidEmail<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return invalidEmail?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return invalidEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({required String failedValue}) = _$InvalidEmail<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShortPasswordCopyWith<T, $Res> {
  factory $ShortPasswordCopyWith(
          ShortPassword<T> value, $Res Function(ShortPassword<T>) then) =
      _$ShortPasswordCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortPasswordCopyWith<T, $Res> {
  _$ShortPasswordCopyWithImpl(
      ShortPassword<T> _value, $Res Function(ShortPassword<T>) _then)
      : super(_value, (v) => _then(v as ShortPassword<T>));

  @override
  ShortPassword<T> get _value => super._value as ShortPassword<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(ShortPassword<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ShortPassword<T> implements ShortPassword<T> {
  const _$ShortPassword({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ShortPassword<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      _$ShortPasswordCopyWithImpl<T, ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return shortPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return shortPassword?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return shortPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  const factory ShortPassword({required String failedValue}) =
      _$ShortPassword<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PasswordMisMatchCopyWith<T, $Res> {
  factory $PasswordMisMatchCopyWith(
          PasswordMisMatch<T> value, $Res Function(PasswordMisMatch<T>) then) =
      _$PasswordMisMatchCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$PasswordMisMatchCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $PasswordMisMatchCopyWith<T, $Res> {
  _$PasswordMisMatchCopyWithImpl(
      PasswordMisMatch<T> _value, $Res Function(PasswordMisMatch<T>) _then)
      : super(_value, (v) => _then(v as PasswordMisMatch<T>));

  @override
  PasswordMisMatch<T> get _value => super._value as PasswordMisMatch<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(PasswordMisMatch<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PasswordMisMatch<T> implements PasswordMisMatch<T> {
  const _$PasswordMisMatch({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.passwordMisMatch(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is PasswordMisMatch<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $PasswordMisMatchCopyWith<T, PasswordMisMatch<T>> get copyWith =>
      _$PasswordMisMatchCopyWithImpl<T, PasswordMisMatch<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return passwordMisMatch(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return passwordMisMatch?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (passwordMisMatch != null) {
      return passwordMisMatch(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return passwordMisMatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return passwordMisMatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (passwordMisMatch != null) {
      return passwordMisMatch(this);
    }
    return orElse();
  }
}

abstract class PasswordMisMatch<T> implements ValueFailure<T> {
  const factory PasswordMisMatch({required String failedValue}) =
      _$PasswordMisMatch<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $PasswordMisMatchCopyWith<T, PasswordMisMatch<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidPhoneNumberCopyWith<T, $Res> {
  factory $InvalidPhoneNumberCopyWith(InvalidPhoneNumber<T> value,
          $Res Function(InvalidPhoneNumber<T>) then) =
      _$InvalidPhoneNumberCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidPhoneNumberCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidPhoneNumberCopyWith<T, $Res> {
  _$InvalidPhoneNumberCopyWithImpl(
      InvalidPhoneNumber<T> _value, $Res Function(InvalidPhoneNumber<T>) _then)
      : super(_value, (v) => _then(v as InvalidPhoneNumber<T>));

  @override
  InvalidPhoneNumber<T> get _value => super._value as InvalidPhoneNumber<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidPhoneNumber<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidPhoneNumber<T> implements InvalidPhoneNumber<T> {
  const _$InvalidPhoneNumber({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPhoneNumber(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidPhoneNumber<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidPhoneNumberCopyWith<T, InvalidPhoneNumber<T>> get copyWith =>
      _$InvalidPhoneNumberCopyWithImpl<T, InvalidPhoneNumber<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return invalidPhoneNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return invalidPhoneNumber?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return invalidPhoneNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return invalidPhoneNumber?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidPhoneNumber<T> implements ValueFailure<T> {
  const factory InvalidPhoneNumber({required String failedValue}) =
      _$InvalidPhoneNumber<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidPhoneNumberCopyWith<T, InvalidPhoneNumber<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidCardNumberCopyWith<T, $Res> {
  factory $InvalidCardNumberCopyWith(InvalidCardNumber<T> value,
          $Res Function(InvalidCardNumber<T>) then) =
      _$InvalidCardNumberCopyWithImpl<T, $Res>;
  $Res call({String failureValue});
}

/// @nodoc
class _$InvalidCardNumberCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidCardNumberCopyWith<T, $Res> {
  _$InvalidCardNumberCopyWithImpl(
      InvalidCardNumber<T> _value, $Res Function(InvalidCardNumber<T>) _then)
      : super(_value, (v) => _then(v as InvalidCardNumber<T>));

  @override
  InvalidCardNumber<T> get _value => super._value as InvalidCardNumber<T>;

  @override
  $Res call({
    Object? failureValue = freezed,
  }) {
    return _then(InvalidCardNumber<T>(
      failureValue: failureValue == freezed
          ? _value.failureValue
          : failureValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidCardNumber<T> implements InvalidCardNumber<T> {
  const _$InvalidCardNumber({required this.failureValue});

  @override
  final String failureValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidCardNumber(failureValue: $failureValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidCardNumber<T> &&
            const DeepCollectionEquality()
                .equals(other.failureValue, failureValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failureValue));

  @JsonKey(ignore: true)
  @override
  $InvalidCardNumberCopyWith<T, InvalidCardNumber<T>> get copyWith =>
      _$InvalidCardNumberCopyWithImpl<T, InvalidCardNumber<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return invalidCardNumber(failureValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return invalidCardNumber?.call(failureValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidCardNumber != null) {
      return invalidCardNumber(failureValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return invalidCardNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return invalidCardNumber?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidCardNumber != null) {
      return invalidCardNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidCardNumber<T> implements ValueFailure<T> {
  const factory InvalidCardNumber({required String failureValue}) =
      _$InvalidCardNumber<T>;

  String get failureValue;
  @JsonKey(ignore: true)
  $InvalidCardNumberCopyWith<T, InvalidCardNumber<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmptyCardNameCopyWith<T, $Res> {
  factory $EmptyCardNameCopyWith(
          EmptyCardName<T> value, $Res Function(EmptyCardName<T>) then) =
      _$EmptyCardNameCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$EmptyCardNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyCardNameCopyWith<T, $Res> {
  _$EmptyCardNameCopyWithImpl(
      EmptyCardName<T> _value, $Res Function(EmptyCardName<T>) _then)
      : super(_value, (v) => _then(v as EmptyCardName<T>));

  @override
  EmptyCardName<T> get _value => super._value as EmptyCardName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(EmptyCardName<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EmptyCardName<T> implements EmptyCardName<T> {
  const _$EmptyCardName({required this.failedValue});

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.emptyCardName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmptyCardName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $EmptyCardNameCopyWith<T, EmptyCardName<T>> get copyWith =>
      _$EmptyCardNameCopyWithImpl<T, EmptyCardName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return emptyCardName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return emptyCardName?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (emptyCardName != null) {
      return emptyCardName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return emptyCardName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return emptyCardName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (emptyCardName != null) {
      return emptyCardName(this);
    }
    return orElse();
  }
}

abstract class EmptyCardName<T> implements ValueFailure<T> {
  const factory EmptyCardName({required String failedValue}) =
      _$EmptyCardName<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $EmptyCardNameCopyWith<T, EmptyCardName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidCardDateCopyWith<T, $Res> {
  factory $InvalidCardDateCopyWith(
          InvalidCardDate<T> value, $Res Function(InvalidCardDate<T>) then) =
      _$InvalidCardDateCopyWithImpl<T, $Res>;
  $Res call({String failureValue});
}

/// @nodoc
class _$InvalidCardDateCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidCardDateCopyWith<T, $Res> {
  _$InvalidCardDateCopyWithImpl(
      InvalidCardDate<T> _value, $Res Function(InvalidCardDate<T>) _then)
      : super(_value, (v) => _then(v as InvalidCardDate<T>));

  @override
  InvalidCardDate<T> get _value => super._value as InvalidCardDate<T>;

  @override
  $Res call({
    Object? failureValue = freezed,
  }) {
    return _then(InvalidCardDate<T>(
      failureValue: failureValue == freezed
          ? _value.failureValue
          : failureValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidCardDate<T> implements InvalidCardDate<T> {
  const _$InvalidCardDate({required this.failureValue});

  @override
  final String failureValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidCardDate(failureValue: $failureValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidCardDate<T> &&
            const DeepCollectionEquality()
                .equals(other.failureValue, failureValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failureValue));

  @JsonKey(ignore: true)
  @override
  $InvalidCardDateCopyWith<T, InvalidCardDate<T>> get copyWith =>
      _$InvalidCardDateCopyWithImpl<T, InvalidCardDate<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return invalidCardDate(failureValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return invalidCardDate?.call(failureValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidCardDate != null) {
      return invalidCardDate(failureValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return invalidCardDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return invalidCardDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidCardDate != null) {
      return invalidCardDate(this);
    }
    return orElse();
  }
}

abstract class InvalidCardDate<T> implements ValueFailure<T> {
  const factory InvalidCardDate({required String failureValue}) =
      _$InvalidCardDate<T>;

  String get failureValue;
  @JsonKey(ignore: true)
  $InvalidCardDateCopyWith<T, InvalidCardDate<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidCVVCopyWith<T, $Res> {
  factory $InvalidCVVCopyWith(
          InvalidCVV<T> value, $Res Function(InvalidCVV<T>) then) =
      _$InvalidCVVCopyWithImpl<T, $Res>;
  $Res call({String failureValue});
}

/// @nodoc
class _$InvalidCVVCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidCVVCopyWith<T, $Res> {
  _$InvalidCVVCopyWithImpl(
      InvalidCVV<T> _value, $Res Function(InvalidCVV<T>) _then)
      : super(_value, (v) => _then(v as InvalidCVV<T>));

  @override
  InvalidCVV<T> get _value => super._value as InvalidCVV<T>;

  @override
  $Res call({
    Object? failureValue = freezed,
  }) {
    return _then(InvalidCVV<T>(
      failureValue: failureValue == freezed
          ? _value.failureValue
          : failureValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidCVV<T> implements InvalidCVV<T> {
  const _$InvalidCVV({required this.failureValue});

  @override
  final String failureValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidCVV(failureValue: $failureValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidCVV<T> &&
            const DeepCollectionEquality()
                .equals(other.failureValue, failureValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failureValue));

  @JsonKey(ignore: true)
  @override
  $InvalidCVVCopyWith<T, InvalidCVV<T>> get copyWith =>
      _$InvalidCVVCopyWithImpl<T, InvalidCVV<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String failedValue) emptyUserName,
    required TResult Function(String failedValue) invalidEmail,
    required TResult Function(String failedValue) shortPassword,
    required TResult Function(String failedValue) passwordMisMatch,
    required TResult Function(String failedValue) invalidPhoneNumber,
    required TResult Function(String failureValue) invalidCardNumber,
    required TResult Function(String failedValue) emptyCardName,
    required TResult Function(String failureValue) invalidCardDate,
    required TResult Function(String failureValue) invalidCVV,
  }) {
    return invalidCVV(failureValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
  }) {
    return invalidCVV?.call(failureValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String failedValue)? emptyUserName,
    TResult Function(String failedValue)? invalidEmail,
    TResult Function(String failedValue)? shortPassword,
    TResult Function(String failedValue)? passwordMisMatch,
    TResult Function(String failedValue)? invalidPhoneNumber,
    TResult Function(String failureValue)? invalidCardNumber,
    TResult Function(String failedValue)? emptyCardName,
    TResult Function(String failureValue)? invalidCardDate,
    TResult Function(String failureValue)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidCVV != null) {
      return invalidCVV(failureValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EmptyUserName<T> value) emptyUserName,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(PasswordMisMatch<T> value) passwordMisMatch,
    required TResult Function(InvalidPhoneNumber<T> value) invalidPhoneNumber,
    required TResult Function(InvalidCardNumber<T> value) invalidCardNumber,
    required TResult Function(EmptyCardName<T> value) emptyCardName,
    required TResult Function(InvalidCardDate<T> value) invalidCardDate,
    required TResult Function(InvalidCVV<T> value) invalidCVV,
  }) {
    return invalidCVV(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
  }) {
    return invalidCVV?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EmptyUserName<T> value)? emptyUserName,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(PasswordMisMatch<T> value)? passwordMisMatch,
    TResult Function(InvalidPhoneNumber<T> value)? invalidPhoneNumber,
    TResult Function(InvalidCardNumber<T> value)? invalidCardNumber,
    TResult Function(EmptyCardName<T> value)? emptyCardName,
    TResult Function(InvalidCardDate<T> value)? invalidCardDate,
    TResult Function(InvalidCVV<T> value)? invalidCVV,
    required TResult orElse(),
  }) {
    if (invalidCVV != null) {
      return invalidCVV(this);
    }
    return orElse();
  }
}

abstract class InvalidCVV<T> implements ValueFailure<T> {
  const factory InvalidCVV({required String failureValue}) = _$InvalidCVV<T>;

  String get failureValue;
  @JsonKey(ignore: true)
  $InvalidCVVCopyWith<T, InvalidCVV<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
